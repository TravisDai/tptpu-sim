!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CC	Makefile	/^CC = g++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g$/;"	m
CPU	cpu.cpp	/^CPU::CPU() {$/;"	f	class:CPU
CPU	cpu.hpp	/^class CPU {$/;"	c
Controller	controller.cpp	/^Controller::Controller(MatrixMultiplyUnit *matrixmultiplyunit,$/;"	f	class:Controller
Controller	controller.hpp	/^class Controller {$/;"	c
Cycle	buffer.cpp	/^void UnifiedBuffer::Cycle() {$/;"	f	class:UnifiedBuffer
Cycle	cpu.cpp	/^void CPU::Cycle() {$/;"	f	class:CPU
Cycle	dram.cpp	/^void DRAM::Cycle() {$/;"	f	class:DRAM
Cycle	interconnect.cpp	/^void Interconnect::Cycle() {$/;"	f	class:Interconnect
Cycle	mmu.cpp	/^void MatrixMultiplyUnit::Cycle() {$/;"	f	class:MatrixMultiplyUnit
Cycle	weightfetcher.cpp	/^void WeightFetcher::Cycle() {$/;"	f	class:WeightFetcher
DRAM	dram.cpp	/^DRAM::DRAM() {$/;"	f	class:DRAM
DRAM	dram.hpp	/^class DRAM {$/;"	c
GetAccumulatorSize	mmu.hpp	/^    int GetAccumulatorSize() {return accumulator_size;}$/;"	f	class:MatrixMultiplyUnit
GetActivationTileQueue	cpu.hpp	/^    std::vector<tile> *GetActivationTileQueue() {return activation_tile_queue;}$/;"	f	class:CPU
GetCapacity	buffer.hpp	/^    float GetCapacity() {return capacity;}$/;"	f	class:UnifiedBuffer
GetCapacity	mmu.hpp	/^    float GetCapacity() {return capacity;}$/;"	f	class:MatrixMultiplyUnit
GetCapacity	weightfetcher.hpp	/^    float GetCapacity() {return size * (float)depth;}$/;"	f	class:WeightFetcher
GetRequestQueue	buffer.hpp	/^    std::vector<request> *GetRequestQueue() {return request_queue;}$/;"	f	class:UnifiedBuffer
GetRequestQueue	interconnect.hpp	/^    std::vector<request> *GetRequestQueue() {return request_queue;}$/;"	f	class:Interconnect
GetRequestQueue	mmu.hpp	/^    std::vector<request> *GetRequestQueue() {assert(0); return new std::vector<request>();}$/;"	f	class:MatrixMultiplyUnit
GetRequestQueue	weightfetcher.hpp	/^    std::vector<request> *GetRequestQueue() {return request_queue;}$/;"	f	class:WeightFetcher
GetSenderQueue	buffer.hpp	/^    std::vector<request> *GetSenderQueue() {return sender_queue;}$/;"	f	class:UnifiedBuffer
GetSenderQueue	cpu.hpp	/^    std::vector<request> *GetSenderQueue() {return sender_queue;}$/;"	f	class:CPU
GetSenderQueue	dram.hpp	/^    std::vector<request> *GetSenderQueue() {return sender_queue;}$/;"	f	class:DRAM
GetSenderQueue	interconnect.hpp	/^    std::vector<request> *GetSenderQueue() {return sender_queue;}$/;"	f	class:Interconnect
GetSenderQueue	mmu.hpp	/^    std::vector<request> *GetSenderQueue()  {assert(0); return new std::vector<request>();}$/;"	f	class:MatrixMultiplyUnit
GetSenderQueue	weightfetcher.hpp	/^    std::vector<request> *GetSenderQueue() {return sender_queue;}$/;"	f	class:WeightFetcher
GetServedQueue	buffer.hpp	/^    std::vector<request> *GetServedQueue() {return served_queue;}$/;"	f	class:UnifiedBuffer
GetServedQueue	interconnect.hpp	/^    std::vector<request> *GetServedQueue() {return served_queue;}$/;"	f	class:Interconnect
GetServedQueue	mmu.hpp	/^    std::vector<request> *GetServedQueue()  {assert(0); return new std::vector<request>();}$/;"	f	class:MatrixMultiplyUnit
GetServedQueue	weightfetcher.hpp	/^    std::vector<request> *GetServedQueue() {return served_queue;}$/;"	f	class:WeightFetcher
GetSystolicArrayHeight	mmu.hpp	/^    int GetSystolicArrayHeight() {return systolic_array_height;}$/;"	f	class:MatrixMultiplyUnit
GetSystolicArrayWidth	mmu.hpp	/^    int GetSystolicArrayWidth() {return systolic_array_width;}$/;"	f	class:MatrixMultiplyUnit
GetUBRequestQueue	mmu.hpp	/^    std::vector<request> *GetUBRequestQueue()   {return ub_request_queue;}$/;"	f	class:MatrixMultiplyUnit
GetUBServedQueue	mmu.hpp	/^    std::vector<request> *GetUBServedQueue()    {return ub_served_queue;}$/;"	f	class:MatrixMultiplyUnit
GetUBWaitingQueue	mmu.hpp	/^    std::vector<request> *GetUBWaitingQueue()   {return ub_waiting_queue;}$/;"	f	class:MatrixMultiplyUnit
GetWFRequestQueue	mmu.hpp	/^    std::vector<request> *GetWFRequestQueue()   {return wf_request_queue;}$/;"	f	class:MatrixMultiplyUnit
GetWFServedQueue	mmu.hpp	/^    std::vector<request> *GetWFServedQueue()    {return wf_served_queue;}$/;"	f	class:MatrixMultiplyUnit
GetWFWaitingQueue	mmu.hpp	/^    std::vector<request> *GetWFWaitingQueue()   {return wf_waiting_queue;}$/;"	f	class:MatrixMultiplyUnit
GetWaitingQueue	buffer.hpp	/^    std::vector<request> *GetWaitingQueue() {return waiting_queue;}$/;"	f	class:UnifiedBuffer
GetWaitingQueue	interconnect.hpp	/^    std::vector<request> *GetWaitingQueue() {return waiting_queue;}$/;"	f	class:Interconnect
GetWaitingQueue	mmu.hpp	/^    std::vector<request> *GetWaitingQueue() {assert(0); return new std::vector<request>();}$/;"	f	class:MatrixMultiplyUnit
GetWaitingQueue	weightfetcher.hpp	/^    std::vector<request> *GetWaitingQueue() {return waiting_queue;}$/;"	f	class:WeightFetcher
GetWeightTileQueue	dram.hpp	/^    std::vector<tile> *GetWeightTileQueue() {return weight_tile_queue;}$/;"	f	class:DRAM
Interconnect	interconnect.cpp	/^Interconnect::Interconnect(Unit *_sender, Unit *_receiver, float _clock, float _bw, float _receiver_capacity,$/;"	f	class:Interconnect
Interconnect	interconnect.hpp	/^class Interconnect {$/;"	c
IsIdle	interconnect.cpp	/^bool Interconnect::IsIdle() {$/;"	f	class:Interconnect
IsIdle	mmu.cpp	/^bool MatrixMultiplyUnit::IsIdle() {$/;"	f	class:MatrixMultiplyUnit
IsMainMemory	buffer.hpp	/^    bool IsMainMemory() {return is_main_memory;}$/;"	f	class:UnifiedBuffer
IsMainMemory	cpu.hpp	/^    bool IsMainMemory() {return is_main_memory;}$/;"	f	class:CPU
IsMainMemory	dram.hpp	/^    bool IsMainMemory() {return is_main_memory;}$/;"	f	class:DRAM
IsMainMemory	mmu.hpp	/^    bool IsMainMemory() {return is_main_memory;}$/;"	f	class:MatrixMultiplyUnit
IsMainMemory	weightfetcher.hpp	/^    bool IsMainMemory() {return is_main_memory;}$/;"	f	class:WeightFetcher
IsMatrixMultiplyUnit	mmu.hpp	/^    bool IsMatrixMultiplyUnit() {return true;}$/;"	f	class:MatrixMultiplyUnit
IsMatrixMultiplyUnit	unit.hpp	/^    virtual bool IsMatrixMultiplyUnit() {return false;}$/;"	f	class:Unit
MakeRequest	common.cpp	/^request MakeRequest(int order, float size) {$/;"	f
MakeTile	common.cpp	/^tile MakeTile(int order, unsigned int starting_address, int tile_width, int tile_height, int total_width, int total_height) {$/;"	f
MatrixMultiply	controller.cpp	/^void Controller::MatrixMultiply(int A, int B, int C, bool is_dimension_nchw, int channel,$/;"	f	class:Controller
MatrixMultiplyUnit	mmu.cpp	/^MatrixMultiplyUnit::MatrixMultiplyUnit(int sa_width, int sa_height, int acc_size, UnifiedBuffer *unifiedbuffer, WeightFetcher *weightfetcher) {$/;"	f	class:MatrixMultiplyUnit
MatrixMultiplyUnit	mmu.hpp	/^class MatrixMultiplyUnit: public Unit {$/;"	c
OBJS1	Makefile	/^OBJS1 = buffer.cpp common.cpp cpu.cpp interconnect.cpp test_cpu_icnt_ub.cpp$/;"	m
OBJS2	Makefile	/^OBJS2 = buffer.cpp common.cpp cpu.cpp dram.cpp interconnect.cpp weightfetcher.cpp test_dram_icnt_wf.cpp$/;"	m
OBJS3	Makefile	/^OBJS3 = buffer.cpp common.cpp cpu.cpp dram.cpp interconnect.cpp mmu.cpp weightfetcher.cpp test_mmu.cpp$/;"	m
OBJST	Makefile	/^OBJST = buffer.cpp common.cpp controller.cpp mmu.cpp test_tile.cpp weightfetcher.cpp$/;"	m
PrintAllTiles	controller.cpp	/^void Controller::PrintAllTiles() {$/;"	f	class:Controller
PrintStats	interconnect.cpp	/^void Interconnect::PrintStats(std::string name) {$/;"	f	class:Interconnect
PrintStats	mmu.cpp	/^void MatrixMultiplyUnit::PrintStats() {$/;"	f	class:MatrixMultiplyUnit
PushRequestsFromTiles	controller.cpp	/^void Controller::PushRequestsFromTiles() {$/;"	f	class:Controller
ReceiveRequest	interconnect.cpp	/^void Interconnect::ReceiveRequest(request req) {$/;"	f	class:Interconnect
ReceiverFull	interconnect.cpp	/^bool Interconnect::ReceiverFull() {$/;"	f	class:Interconnect
ReceiversSenderQueueSize	interconnect.cpp	/^float Interconnect::ReceiversSenderQueueSize() {$/;"	f	class:Interconnect
Tile	controller.cpp	/^void Controller::Tile(int A, int B, int C, bool is_dimension_nchw, int channel,$/;"	f	class:Controller
UnifiedBuffer	buffer.cpp	/^UnifiedBuffer::UnifiedBuffer(float buffer_size) {$/;"	f	class:UnifiedBuffer
UnifiedBuffer	buffer.hpp	/^class UnifiedBuffer: public Unit {$/;"	c
Unit	unit.hpp	/^class Unit {$/;"	c
UpdateTilingQueue	mmu.cpp	/^void MatrixMultiplyUnit::UpdateTilingQueue() {$/;"	f	class:MatrixMultiplyUnit
WeightFetcher	weightfetcher.cpp	/^WeightFetcher::WeightFetcher(float _size, int _depth) {$/;"	f	class:WeightFetcher
WeightFetcher	weightfetcher.hpp	/^class WeightFetcher: public Unit {$/;"	c
accumulator_size	controller.hpp	/^    int accumulator_size;$/;"	m	class:Controller
accumulator_size	mmu.hpp	/^    int accumulator_size;           \/\/ size of accumulator, probably 2048$/;"	m	class:MatrixMultiplyUnit
activation_tile_queue	controller.hpp	/^    std::vector<tile> *activation_tile_queue;$/;"	m	class:Controller
activation_tile_queue	cpu.hpp	/^    std::vector<tile> *activation_tile_queue;$/;"	m	class:CPU
bpc	interconnect.hpp	/^    float bpc;                              \/\/ bytes sent per cycle$/;"	m	class:Interconnect
busy_cycle	interconnect.hpp	/^    int busy_cycle;                         \/\/ number of cycles that the interconnect was busy$/;"	m	class:Interconnect
busy_cycle	mmu.hpp	/^    int busy_cycle;                 \/\/ number of cycles Matrix Multiply Unit performed computations$/;"	m	class:MatrixMultiplyUnit
bw	interconnect.hpp	/^    float bw;                               \/\/ bandwidth in GB\/s$/;"	m	class:Interconnect
capacity	buffer.hpp	/^    float capacity;         \/\/ 2 x size of one buffer$/;"	m	class:UnifiedBuffer
capacity	mmu.hpp	/^    float capacity;                 \/\/ systolic_array_width x systolic_array_height$/;"	m	class:MatrixMultiplyUnit
clock	interconnect.hpp	/^    float clock;                            \/\/ clock in GHz$/;"	m	class:Interconnect
current_order	mmu.hpp	/^    int current_order;              \/\/ the order being computer right now, 0 if none$/;"	m	class:MatrixMultiplyUnit
depth	weightfetcher.hpp	/^    int depth;$/;"	m	class:WeightFetcher
find_and_delete_by_order	common.cpp	/^void find_and_delete_by_order(std::vector<request> &v, int order) {$/;"	f
find_and_delete_by_order	common.cpp	/^void find_and_delete_by_order(std::vector<tile> &v, int order) {$/;"	f
id	controller.hpp	/^    int id;             \/\/ number to set for next request's order in tiling process$/;"	m	class:Controller
idle_cycle	interconnect.hpp	/^    int idle_cycle;                         \/\/ number of cycles that the interconnect was idle$/;"	m	class:Interconnect
idle_cycle	mmu.hpp	/^    int idle_cycle;                 \/\/ number of cycles Matrix Multiply Unit performed no computations$/;"	m	class:MatrixMultiplyUnit
is_main_memory	buffer.hpp	/^    bool is_main_memory;$/;"	m	class:UnifiedBuffer
is_main_memory	cpu.hpp	/^    bool is_main_memory;$/;"	m	class:CPU
is_main_memory	dram.hpp	/^    bool is_main_memory;$/;"	m	class:DRAM
is_main_memory	mmu.hpp	/^    bool is_main_memory;$/;"	m	class:MatrixMultiplyUnit
is_main_memory	weightfetcher.hpp	/^    bool is_main_memory;$/;"	m	class:WeightFetcher
is_sender_main_memory	interconnect.hpp	/^    bool is_sender_main_memory;             \/\/ whether the sender is main memory or not$/;"	m	class:Interconnect
main	test_cpu_icnt_ub.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	test_dram_icnt_wf.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	test_mmu.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	test_tile.cpp	/^int main(int argc, char *argv[]) {$/;"	f
mmu	controller.hpp	/^    MatrixMultiplyUnit *mmu;$/;"	m	class:Controller
order	common.hpp	/^    int order;$/;"	m	struct:request
order	common.hpp	/^    int order;$/;"	m	struct:tile
pop_front	common.cpp	/^void pop_front(std::vector<request> &v) {$/;"	f
pop_front	common.cpp	/^void pop_front(std::vector<tile> &v) {$/;"	f
receiver	interconnect.hpp	/^    Unit *receiver;                         \/\/ pointer to the receiver of this interconnect$/;"	m	class:Interconnect
receiver_capacity	interconnect.hpp	/^    float receiver_capacity;                \/\/ total amount of bytes the receiver can endure (store) up to$/;"	m	class:Interconnect
request	common.hpp	/^struct request {$/;"	s
request	common.hpp	/^typedef struct request request;$/;"	t	typeref:struct:request
request_queue	buffer.hpp	/^    std::vector<request> *request_queue;$/;"	m	class:UnifiedBuffer
request_queue	interconnect.hpp	/^    std::vector<request> *request_queue;    \/\/ vector of requests that the receiver needs to request to sender$/;"	m	class:Interconnect
request_queue	weightfetcher.hpp	/^    std::vector<request> *request_queue;$/;"	m	class:WeightFetcher
sender	interconnect.hpp	/^    Unit *sender;                           \/\/ pointer to the sender of this interconnect$/;"	m	class:Interconnect
sender_queue	buffer.hpp	/^    std::vector<request> *sender_queue;$/;"	m	class:UnifiedBuffer
sender_queue	cpu.hpp	/^    std::vector<request> *sender_queue;$/;"	m	class:CPU
sender_queue	dram.hpp	/^    std::vector<request> *sender_queue;$/;"	m	class:DRAM
sender_queue	interconnect.hpp	/^    std::vector<request> *sender_queue;     \/\/ vector of requests that sender has left to send to receiver (size changes)$/;"	m	class:Interconnect
sender_queue	weightfetcher.hpp	/^    std::vector<request> *sender_queue;$/;"	m	class:WeightFetcher
sent_size	interconnect.hpp	/^    float sent_size;                        \/\/ total number of bytes sent over this interconnect$/;"	m	class:Interconnect
served_queue	buffer.hpp	/^    std::vector<request> *served_queue;$/;"	m	class:UnifiedBuffer
served_queue	interconnect.hpp	/^    std::vector<request> *served_queue;     \/\/ vector of requests that the receiver has been serviced$/;"	m	class:Interconnect
served_queue	weightfetcher.hpp	/^    std::vector<request> *served_queue;$/;"	m	class:WeightFetcher
size	common.hpp	/^    float size;$/;"	m	struct:request
size	weightfetcher.hpp	/^    float size;$/;"	m	class:WeightFetcher
starting_address	common.hpp	/^    unsigned int starting_address;$/;"	m	struct:tile
systolic_array_height	controller.hpp	/^    int systolic_array_height;$/;"	m	class:Controller
systolic_array_height	mmu.hpp	/^    int systolic_array_height;      \/\/ how far deep the values can go$/;"	m	class:MatrixMultiplyUnit
systolic_array_width	controller.hpp	/^    int systolic_array_width;$/;"	m	class:Controller
systolic_array_width	mmu.hpp	/^    int systolic_array_width;       \/\/ how many values come each cycle from UnifiedBuffer$/;"	m	class:MatrixMultiplyUnit
tile	common.hpp	/^struct tile {$/;"	s
tile	common.hpp	/^typedef struct tile tile;$/;"	t	typeref:struct:tile
tile_height	common.hpp	/^    int tile_height;$/;"	m	struct:tile
tile_width	common.hpp	/^    int tile_width;$/;"	m	struct:tile
tiling_queue	mmu.hpp	/^    std::vector<request> *tiling_queue;$/;"	m	class:MatrixMultiplyUnit
total_computation_number	mmu.hpp	/^    float total_computation_number; \/\/ total number of computations Matrix Multiply Unit performed$/;"	m	class:MatrixMultiplyUnit
total_height	common.hpp	/^    int total_height;$/;"	m	struct:tile
total_width	common.hpp	/^    int total_width;$/;"	m	struct:tile
ub	mmu.hpp	/^    UnifiedBuffer *ub;              \/\/ pointer to Unified Buffer connected to this unit$/;"	m	class:MatrixMultiplyUnit
ub_request_queue	mmu.hpp	/^    std::vector<request> *ub_request_queue;$/;"	m	class:MatrixMultiplyUnit
ub_served_queue	mmu.hpp	/^    std::vector<request> *ub_served_queue;$/;"	m	class:MatrixMultiplyUnit
ub_waiting_queue	mmu.hpp	/^    std::vector<request> *ub_waiting_queue;$/;"	m	class:MatrixMultiplyUnit
wait_cycle	mmu.hpp	/^    int wait_cycle;                 \/\/ number of cycles Matrix Multiply Unit needs to wait (is computing)$/;"	m	class:MatrixMultiplyUnit
waiting_queue	buffer.hpp	/^    std::vector<request> *waiting_queue;$/;"	m	class:UnifiedBuffer
waiting_queue	interconnect.hpp	/^    std::vector<request> *waiting_queue;    \/\/ vector of requests that the receiver has to receive from sender$/;"	m	class:Interconnect
waiting_queue	weightfetcher.hpp	/^    std::vector<request> *waiting_queue;$/;"	m	class:WeightFetcher
weight_tile_queue	controller.hpp	/^    std::vector<tile> *weight_tile_queue;$/;"	m	class:Controller
weight_tile_queue	dram.hpp	/^    std::vector<tile> *weight_tile_queue;$/;"	m	class:DRAM
wf	mmu.hpp	/^    WeightFetcher *wf;              \/\/ pointer to Weight Fetcher connected to this unit$/;"	m	class:MatrixMultiplyUnit
wf_request_queue	mmu.hpp	/^    std::vector<request> *wf_request_queue;$/;"	m	class:MatrixMultiplyUnit
wf_served_queue	mmu.hpp	/^    std::vector<request> *wf_served_queue;$/;"	m	class:MatrixMultiplyUnit
wf_waiting_queue	mmu.hpp	/^    std::vector<request> *wf_waiting_queue;$/;"	m	class:MatrixMultiplyUnit
~CPU	cpu.cpp	/^CPU::~CPU() {$/;"	f	class:CPU
~DRAM	dram.cpp	/^DRAM::~DRAM() {$/;"	f	class:DRAM
~Interconnect	interconnect.cpp	/^Interconnect::~Interconnect() {$/;"	f	class:Interconnect
